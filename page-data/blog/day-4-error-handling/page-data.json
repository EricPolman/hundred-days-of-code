{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/blog/day-4-error-handling","result":{"data":{"markdownRemark":{"html":"<h1>Day 4: Error handling</h1>\n<h2>Introduction</h2>\n<p>I love working with TypeScript, because type-checking makes sure you know what data you have in front of you at any given moment. However, TypeScript has no support for typed errors, so whenever you throw an error you have no idea what it could be. The TypeScript compiler even gives an error when you try to define the type of an error in the catch-block.</p>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/language/catch-multiple.html\">Java</a> and <a href=\"https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-use-the-try-catch-block-to-catch-exceptions\">C#</a> allow a catch-block for every type of Exception that is thrown and will even given an error (or a warning, not sure) if you don't handle all exceptions.</p>\n<p>To handle all errors in TypeScript, you are left to your own devices. You also can't define throwable errors in your function signatures. You have to inspect the function bodies to see which errors they can throw and handle that, or dive deep into the documentation if there is any.</p>\n<p>Today is about finding a solution or a proper workaround to type-safe error handling in TypeScript. <a href=\"https://medium.com/inato/expressive-error-handling-in-typescript-and-benefits-for-domain-driven-design-70726e061c86\">This article</a> describes the issue I am dealing with.</p>\n<h2>Result</h2>\n<p>The result for today is a proof-of-concept that has type-safe error handling using <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\">discriminated unions</a> and explicit type checks.</p>\n<h3>Result handling</h3>\n<p>In <code>result.ts</code> you will find a <code>Result</code> generic type that is either an <code>Ok</code> or an <code>Err</code> class. By defining <code>Result</code> with two generic types (left hand is result, right hand is errors) a discriminating union is setup in the <code>Ok</code> and <code>Err</code> classes. The left hand type is used for the data-property of the <code>Ok</code> class and the right hand type(s) for the <code>Err</code> data.</p>\n<p>Type checking functions (<code>isOk()</code>, <code>isErr()</code>) are in place to determine if an instance of <code>Result</code> is actually <code>Ok</code> or <code>Err</code>. The TypeScript compiler knows that if <code>isOk()</code> is <code>true</code>, the only type <code>Result</code> could be is <code>Ok</code> as <code>Err</code> will always return false on that check.</p>\n<p>Helper functions <code>ok()</code> and <code>err()</code> allow you to return a specific result in a function, as demonstrated in <code>index.ts</code>.</p>\n<h3>Error handling</h3>\n<p>Now that Result helps us determine if there is an error, I want to know what error. In <code>errors.ts</code> I have an enum called <code>ErrorType</code> which houses all possible error types that can be returned in the application. This field is used as the discriminant in the Error classes.</p>\n<p><code>BaseError&#x3C;ET></code> extends the default Error class and takes in an <code>ErrorType</code> value as a generic type. By setting the generic constraint <code>ET extends ErrorType</code>, the type given to <code>BaseError&#x3C;ET></code> has to be a value of <code>ErrorType</code>. In the constructor, this same value must be given, so classes deriving from it</p>\n<p>Errors that derive from <code>BaseError</code> can now setup custom fields for this error type, as demonstrated in <code>BadRequestError</code> and <code>InternalServerError</code> (not great real-world examples of useful extra data, but it's a PoC).</p>\n<h3>Tying it together</h3>\n<p>In <code>index.ts</code> you see a function <code>testFunction</code> that returns either a result that is either an <code>Ok&#x3C;{data: string}></code> or an <code>Err&#x3C;BadRequestError | InternalServerError></code>. Calling this function with a value of 1 results in an ok result, calling it with 2 results in a <code>BadRequestError</code> and anything else will give an <code>InternalServerError</code>.</p>\n<p>I have set up a switch-statement and an if-else-statement that both show the type inferring done by TypeScript. As TypeScript is aware which types the error can be, any switch-case that is not part of the <code>Errors</code> in the function definition for <code>testFunction</code> will give a compilation error. In the cases that are valid, the type is correctly determined and you can use the custom properties of an error.</p>\n<p>The if-else-statement shows that checking the discriminant (<code>error.type</code>) for <code>ErrorType.BadRequest</code> correctly determines the type as <code>BadRequestError</code> in the if-block. The else-block has only one other error type that is not handled yet (<code>ErrorType.InternalServerError</code>) and therefore must be an <code>InternalServerError</code>, allowing access to its <code>status</code> property.</p>","fileAbsolutePath":"/Users/ericpolman/git/pp/thirty-days-of-code/submissions/day-004-error-handling/README.md","frontmatter":{"date":"April 30, 2020","path":"/blog/day-4-error-handling","title":"Day 4: Error handling"}}},"pageContext":{}}}